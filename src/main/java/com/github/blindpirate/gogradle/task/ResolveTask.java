package com.github.blindpirate.gogradle.task;

import com.github.blindpirate.gogradle.GolangPluginSetting;
import com.github.blindpirate.gogradle.common.GoSourceCodeFilter;
import com.github.blindpirate.gogradle.core.GolangConfiguration;
import com.github.blindpirate.gogradle.core.GolangConfigurationManager;
import com.github.blindpirate.gogradle.core.cache.ProjectCacheManager;
import com.github.blindpirate.gogradle.core.dependency.GolangDependency;
import com.github.blindpirate.gogradle.core.dependency.LocalDirectoryDependency;
import com.github.blindpirate.gogradle.core.dependency.ResolveContext;
import com.github.blindpirate.gogradle.core.dependency.produce.DefaultDependencyVisitor;
import com.github.blindpirate.gogradle.core.dependency.produce.DependencyVisitor;
import com.github.blindpirate.gogradle.core.dependency.produce.ExternalDependencyFactory;
import com.github.blindpirate.gogradle.core.dependency.produce.GoImportExtractor;
import com.github.blindpirate.gogradle.core.dependency.produce.VendorDependencyFactory;
import com.github.blindpirate.gogradle.core.dependency.produce.strategy.GogradleRootProduceStrategy;
import com.github.blindpirate.gogradle.core.dependency.tree.DependencyTreeFactory;
import com.github.blindpirate.gogradle.core.dependency.tree.DependencyTreeNode;
import com.github.blindpirate.gogradle.util.Assert;
import com.github.blindpirate.gogradle.util.IOUtils;
import org.gradle.api.tasks.Input;
import org.gradle.api.tasks.InputFiles;
import org.gradle.api.tasks.OutputFile;
import org.gradle.api.tasks.TaskAction;

import javax.inject.Inject;
import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.stream.Collectors;

import static com.github.blindpirate.gogradle.task.GolangTaskContainer.PREPARE_TASK_NAME;
import static com.github.blindpirate.gogradle.util.IOUtils.filterFilesRecursively;

public abstract class ResolveTask extends AbstractGolangTask {
    @Inject
    private GolangPluginSetting setting;

    @Inject
    private DependencyTreeFactory dependencyTreeFactory;

    @Inject
    private GogradleRootProduceStrategy strategy;

    @Inject
    private GolangConfigurationManager configurationManager;

    @Inject
    private DependencyVisitor visitor;

    @Inject
    private ProjectCacheManager projectCacheManager;

    @Inject
    @DefaultDependencyVisitor.ExternalDependencyFactories
    private List<ExternalDependencyFactory> externalDependencyFactories;

    private DependencyTreeNode dependencyTree;

    public ResolveTask() {
        dependsOn(PREPARE_TASK_NAME);
    }

    // INPUT 1: dependencies declared in build.gradle
    @Input
    public HashSet<GolangDependency> getDependencies() {
        GolangConfiguration configuration = configurationManager.getByName(getConfigurationName());
        // elements in GolangDependency are identified by name, here we want to identify them by equals
        return new HashSet<>(configuration.getDependencies());
    }

    // INPUT 2: lockfiles generated by external dependency management tools (including Gogradle itself)
    @InputFiles
    public List<File> getExternalLockfiles() throws IOException {
        return externalDependencyFactories.stream()
                .map(factory -> new File(getProject().getRootDir(), factory.identityFileName()))
                .filter(File::isFile)
                .filter(File::exists)
                .collect(Collectors.toList());
    }

    // INPUT 3: vendor directory
    @InputFiles
    public List<File> getVendorDirectory() {
        File ret = new File(getProject().getRootDir(), VendorDependencyFactory.VENDOR_DIRECTORY);
        return ret.exists() ? Arrays.asList(ret) : Collections.emptyList();
    }

    // INPUT 4: all go files in specific configuration
    @InputFiles
    public Collection<File> getGoSourceFiles() {
        GoSourceCodeFilter filter = GoImportExtractor.FILTERS.get(getConfigurationName());
        return filterFilesRecursively(getProject().getRootDir(), filter);
    }

    @Input
    public List<String> getBuildTags() {
        return setting.getBuildTags();
    }

//    @InputFiles
//    public List<File> getLocalDirDependencies() {
//        return getDependencies().stream()
//                .filter(dependency -> dependency instanceof LocalDirectoryDependency)
//                .map(dependency -> (LocalDirectoryDependency) dependency)
//                .map(LocalDirectoryDependency::getRootDir)
//                .collect(Collectors.toList());
//    }

    @OutputFile
    public File getSerializationFile() {
        return new File(getProject().getRootDir(), ".gogradle/cache/" + getConfigurationName() + ".bin");
    }

    @TaskAction
    public void resolve() {
        projectCacheManager.loadPersistenceCache();
        resolveDependencies();
        writeToSerializationFile();
        projectCacheManager.savePersistenceCache();
    }

    private void writeToSerializationFile() {
        IOUtils.serialize(dependencyTree, getSerializationFile());
    }


    private void resolveDependencies() {
        File rootDir = getProject().getRootDir();
        LocalDirectoryDependency rootProject = LocalDirectoryDependency.fromLocal(
                setting.getPackagePath(),
                rootDir);

        GolangConfiguration configuration = configurationManager.getByName(getConfigurationName());
        ResolveContext rootContext = ResolveContext.root(configuration);
        rootProject.setDependencies(strategy.produce(rootProject,
                rootDir,
                visitor,
                getConfigurationName()));

        dependencyTree = dependencyTreeFactory.getTree(rootContext, rootProject);
    }

    public DependencyTreeNode getDependencyTree() {
        if (dependencyTree == null) {
            readFromSerializationFile();
        }
        return dependencyTree;
    }

    private void readFromSerializationFile() {
        File serializationFile = getSerializationFile();
        Assert.isTrue(serializationFile.exists());
        dependencyTree = (DependencyTreeNode) IOUtils.deserialize(serializationFile);
    }


    public abstract String getConfigurationName();

}
